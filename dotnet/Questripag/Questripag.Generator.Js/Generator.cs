using System.Reflection;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.RegularExpressions;
using System.Web.Mvc;

namespace Questripag.Generator.Js;

public class Generator
{
    public bool GenerateTs { get; private set; }
    public Generator(bool generateTs)
    {
        GenerateTs = generateTs;
    }

    public string Generate(Assembly assembly)
        => Generate(assembly.GetTypes().Where(x => x.IsAssignableTo(typeof(Controller))).SelectMany(x => x.GetMethods(BindingFlags.Instance | BindingFlags.Public)));

    public string Generate(IEnumerable<MethodInfo> methods)
    {
        var asConst = GenerateTs ? " as const" : "";
        return $"""
            /* tslint:disable */
            /* eslint-disable */
            //----------------------
            // <auto-generated>
            //     Generated using Questripag.Generator.Js
            // </auto-generated>
            //----------------------      
            
            export const dataTypes = {GenerateDataTypes()}{asConst};
            export const endpoints = {GenerateData(methods)}{asConst};
            """;
    }

    private string GenerateDataTypes()
    {
        return $"[{string.Join(", ", Enum.GetValues<PropertyType>().Select(x => $"\"{x}\""))}]";
    }

    private Type? GetGenericDefinitionOrNull(Type type)
    {
        return type.IsGenericType ? type.GetGenericTypeDefinition() : null;
    }

    private T? SingleNotNullOrNull<T>(IEnumerable<T?> enumerable)
        where T : class
    {
        T? first = null;
        foreach (var item in enumerable)
        {
            if (item is null) continue;
            if (first is not null) return null;
            first = item;
        }
        return first;
    }

    /// <summary>
    /// Recursively unwraps a nested Page argument.
    /// </summary>
    /// <param name="responseType">A type to unwrap.</param>
    /// <returns>The single page argument or null if there isn't exactly one.</returns>
    private Type? UnwrapPageArgument(Type responseType)
    {
        Type? UnwrapPage(Type type)
        {
            var genericDefinition = GetGenericDefinitionOrNull(type);
            if (genericDefinition == typeof(Page<>)) return type;
            if (genericDefinition != null)
            {
                return SingleNotNullOrNull(type.GenericTypeArguments.Select(UnwrapPage));
            }
            return null;
        }
        var pageType = UnwrapPage(responseType);
        return pageType?.GenericTypeArguments?[0];
    }

    private Type? UnwrapQueryArgument(Type responseType)
    {
        var genericDef = GetGenericDefinitionOrNull(responseType);
        if (genericDef == typeof(Query<>))
        {
            return responseType.GenericTypeArguments[0];
        }
        return null;
    }

    private string GenerateData(IEnumerable<MethodInfo> methods)
    {
        var methodsDict = new Dictionary<string, Dictionary<string, PropertyConfig>>();
        foreach (var method in methods)
        {
            var propertiesDict = new Dictionary<string, PropertyConfig>(StringComparer.InvariantCultureIgnoreCase);
            var responseType = UnwrapPageArgument(method.ReturnType);
            if (responseType != null)
            {
                foreach(var prop in responseType.GetProperties())
                {
                    propertiesDict[prop.SerializationName()] = new PropertyConfig {Response = true, ClrType = prop.PropertyType};
                }
            }
            var requestType = method.GetParameters().Select(x => UnwrapQueryArgument(x.ParameterType)).FirstOrDefault(x => x != null);
            if (requestType != null)
            {
                foreach (var prop in requestType.GetProperties())
                {
                    var config = propertiesDict.GetValueOrDefault(prop.SerializationName(), new() { ClrType = prop.PropertyType });
                    config.Filter = prop.IsFilterProp();
                    config.Order = prop.IsOrderProp();
                    propertiesDict[prop.SerializationName()] = config;
                }
            }
            propertiesDict = new Dictionary<string, PropertyConfig>(propertiesDict.Where(x => x.Value.Response || x.Value.Order || x.Value.Filter));
            if (propertiesDict.Any())
            {
                methodsDict[method.Name] = propertiesDict;
            }
        }
        var result = JsonSerializer.Serialize(methodsDict, new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            WriteIndented = true,
        });
        return Regex.Replace(result, "\"([\\$\\w]+)\":", "$1:");
    }
}
